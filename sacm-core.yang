module sacm-core {
	namespace "http://cisecurity.org/yang/sacm-core";
	prefix sacm-core;

	import "ietf-yang-types" {
		prefix "yang";
	}

	// Do any other modules need inclusion?

	organization "Center for Internet Security";
	contact yang@cisecurity.org;
	description "";
	revision 2018-06-06 {
		description 
			"Initial Version; Types, Groupings, and any other constructs common to SACM.  
			NOTE: Loosely maps to OVAL Common";
	}

	typedef entity-datatype {
		description "The entity-datatype simple type defines the legal datatypes that are used to describe the values of 
				     individual entities. A value should be interpreted according to the specified type. This is most important 
				     during comparisons. For example, is '21' less than '123'? will evaluate to true if the datatypes are 'int', 
				     but will evaluate to 'false' if the datatypes are 'string'. Another example is applying the 'equals' 
				     operation to '1.0.0.0' and '1.0'. With datatype 'string' they are not equal, with datatype 'version' 
				     they are.";
		type enumeration {
			enum binary;
			enum boolean;
			enum evr-string;
			enum fileset-revision;
			enum float;
			enum integer;
			enum ipv4;
			enum ipv6;
			enum string;
			enum version;
			enum record;
			enum debian-evr-string;
			enum cisco-ios-version;
	}

	typedef entity-operation {
		description "Defines acceptable operations. Each operation defines how to compare entities against their actual values.";
		type enumeration {
			enum equals;
			enum not-equal;
			enum case-insensitive-equals;
			enum case-insensitive-not-equal;
			enum greater-than;
			enum greater-than-or-equal-to;
			enum less-than;
			enum less-than-or-equal-to;
			enum bitwise-and;
			enum bitwise-or;
			enum pattern-match;
			enum subset-of;
			enum superset-of;
	}

	typedef entity-logical-operator {
		description "Operators describing the logical combination of results.  Each operator defines how to 
		evaluate multiple arguments.";

		type enumeration {
			enum AND {
				description "The AND operator produces a true result if every argument is true. If one or more 
				arguments are false, the result of the AND is false. If one or more of the arguments are unknown, 
				and if none of the arguments are false, then the AND operator produces a result of unknown.";
			}
			enum OR {
				description "The OR operator produces a true result if one or more arguments is true. If every 
				argument is false, the result of the OR is false. If one or more of the arguments are unknown and 
				if none of arguments are true, then the OR operator produces a result of unknown.";
			}
			enum XOR {
				description "XOR is defined to be true if an odd number of its arguments are true, and false otherwise. 
				If any of the arguments are unknown, then the XOR operator produces a result of unknown.";
			}
			enum ONE {
				description "The ONE operator produces a true result if one and only one argument is true. If there 
				are more than argument is true (or if there are no true arguments), the result of the ONE is false. 
				If one or more of the arguments are unknown, then the ONE operator produces a result of unknown.";
			}
		}
	}

	typedef item-check {
		description "Defines acceptable check values, which are used to determine the final result of something based on the 
		results of individual components. When used to define the relationship between collected characteristics and expected 
		state, each check value defines how many of the matching objects (items except those with a status of does not exist) 
		must satisfy the given state for the test to return true. When used to define the relationship between instances of a 
		given entity, the different check values defines how many instances must be true for the entity to return true. When 
		used to define the relationship between entities and multiple variable values, each check value defines how many variable 
		values must be true for the entity to return true.";

		type enumeration {
			enum all {
				description "A value of 'all' means that a final result of true is given if all the individual results under consideration are true.";
			}
			enum at-least-one {
				description "A value of 'at-least-one' means that a final result of true is given if at least one of the individual results under consideration is true.";
			}
			enum none {
				description "A value of 'none' means that a final result of true is given if none the individual results under consideration are true.";
			}
			enum one {
				description "A value of 'one' means that a final result of true is given if one and only one of the individual results under consideration are true.";
			}
		}
	}

	typedef existence-check {
		description "Defines acceptable existence values, which are used to determine a result based on the existence of individual system characteristics items. 
		The main use for this is for a test regarding the existence of items on the system. Its secondary use is for a state regarding the existence of entities 
		within corresponding items.";

		type enumeration {
			enum all-exist {
				description "When used in the comparison of a system characteristics item element to an expected state, a value of 'all-exist' means that every item 
				entity for an object defined by the description exists on the system. When used in the context of a test's check-existence element, this value is 
				equivalent to 'at-least-one-exists' because non-existent items have no impact upon evaluation.";
			}
			enum any-exist {
				description "A value of 'any-exist' means that zero or more objects defined by the description exist on the system.";
			}
			enum at-least-one-exists {
				description "A value of 'at-least-one-exists' means that at least one object defined by the description exists on the system.";
			}
			enum none-exist {
				description "A value of 'none-exist' means that none of the objects defined by the description exist on the system.";
			}
			enum only-one-exists {
				description "A value of 'only-one-exists' means that only one object defined by the description exists on the system.";
			}
		}
	}

	//
	// Groupings
	//
	grouping entity-base-type {
		leaf name {
			type string;
		}
		leaf datatype {
			type entity-datatype;
		}
		leaf operation {
			type entity-operation;
		}
		leaf nil {
			type boolean;
		}
	}

	grouping entity-int-type {
		uses entity-base-type;

		leaf entity-value {
			type int32;
		}
	}

	grouping entity-string-type {
		uses entity-base-type;

		leaf entity-value {
			type string;
		}
	}

	grouping entity-boolean-type {
		uses entity-base-type;

		leaf entity-value {
			type boolean;
		}
	}

	grouping entity-record-field-type {
		description "";

		leaf name {}
		leaf value {}
	}

	grouping entity-record-type {
		description "";

		uses entity-base-type;

		list fields {
			description "";
			key "name";
			uses record_field;
		} 
	}
}